/* ELM                                                                        */
/* Copyright (C) 2024  Miles McGruder                                         */
/*                                                                            */
/* This program is free software: you can redistribute it and/or modify       */
/* it under the terms of the GNU General Public License as published by       */
/* the Free Software Foundation, either version 3 of the License, or          */
/* (at your option) any later version.                                        */
/*                                                                            */
/* This program is distributed in the hope that it will be useful,            */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of             */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              */
/* GNU General Public License for more details.                               */
/*                                                                            */
/* You should have received a copy of the GNU General Public License          */
/* along with this program.  If not, see <https://www.gnu.org/licenses/>.     */


#version 450


#define BLOCK_SIZE 256
#define REGION_EXP 10
#define REGION_SIZE (1 << REGION_EXP)


layout(local_size_x = BLOCK_SIZE) in;


layout(std430, set = 0, binding = 0) buffer input_size   { uint  isize;  };
layout(std430, set = 0, binding = 1) buffer input_array  { float iarr[]; };
layout(std430, set = 0, binding = 2) buffer output_array { float oarr[]; };


#include "constants.glsl"


shared float sarr[REGION_SIZE];


void main()
{
  // TODO: probably read a little more on shared memory and synchronization

  // load into shared memory, pad with null value if necessary

  for (uint is = gl_LocalInvocationID.x; is < REGION_SIZE; is += BLOCK_SIZE)
  {
    uint ii = REGION_SIZE * gl_WorkGroupID.x + is;  // iterator over input
    if (ii < isize) { sarr[is] = iarr[ii]; }
    else            { sarr[is] = FLT_MAX;  }
  }

  memoryBarrierShared();
  barrier();

  // perform reduction within block

  uint half_size = REGION_SIZE;

  for (uint i = 0; i < REGION_EXP; ++i)
  {
    half_size = half_size >> 1;

    if (uint j = gl_LocalInvocationID.x; j < half_size; j += BLOCK_SIZE)
    {
      sarr[j] = min(sarr[j], sarr[half_size + j]);
    }

    memoryBarrierShared();
    barrier();
  }

  oarr[gl_WorkGroupID.x] = sarr[0];
}
